# -*- coding: utf-8 -*-
"""Floyd.Warshall.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ou018OAKeuj5z-NBOEb-NZjsXKjidgsR
"""

class Graph():
   def __init__(self, vertices):
      self.V = vertices
      #cria matriz de adjacencia para representar arestas e pesos
      self.graph = [[0 for column in range(vertices)]
                       for row in range(vertices)]
   
   #resolve todos os pares via o algoritmo de Floyd-Warshall
   def floydWarshall(self):
      INF = float('inf')
      dist=self.graph

      #considerando cada k como um dos nós intermediarios e percorrendo cada um deles
      for k in range(self.V):
         
         #percorremos todos vertices de origem 1
         for i in range(self.V):
            
            #percorremos todos vertices de destino
            for j in range(self.V):
               #se o vertice k forma o caminho mais curto de i a j
               #então atualiza o valor de dist[i][j]
               if i != j:
                  dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])
               else:
                  dist[i][j] = 0
               #print("i=%s e j=%s dist=%s" % (i,j,dist[i][j]))
      for p in dist:
         for j in p:
            print("%7s" %j, end =" ")
         print("")

INF = float('inf')
g = Graph(8)
g.graph    = [[INF, 1, 4, 1, 5, INF, INF, INF],
              [7, INF, 7, INF, INF, 1, INF, INF],
              [6, 7, INF, INF, INF, INF, INF, INF],
              [INF, INF, INF, INF, INF, 7, INF, INF],
              [INF, INF, INF, INF, INF, INF, 3, 8],
              [INF, 6, INF, 9, INF, INF, INF, 5],
              [INF, INF, 4, INF, 6, 2, INF, 9],
              [INF, INF, INF, INF, INF, 7, INF, INF]]

g.floydWarshall()